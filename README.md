# CleanCodeMemo

- [1章 クリーンコード](#1章-クリーンコード)
- [2章 意味のある名前](#2章-意味のある名前)
- [3章 関数](#3章-関数)
- [4章 コメント](#4章-コメント)
- [5章 書式化](#5章-書式化)
- [6章 オブジェクトとデータ構造](#6章-オブジェクトとデータ構造)
- [7章 エラー処理](#7章-エラー処理)
- [8章 境界](#8章-境界)
- [9章 単体テスト](#9章-単体テスト)
- [10章 クラス](#10章-クラス)

# 1章 クリーンコード
- 長期的に開発をしていくために、読みやすい、綺麗なコードを書く必要がある。


# 2章 意味のある名前

## 意図が明確な名前にする
- 日単位の経過時間 -> elapsedTimeInDays, daysSinceCreation, daysSinceModification, fileAgeInDays...
- theListのような型情報しかない名前は情報がないためよくない。(そもそも型情報を変数名にするのは非推奨)

## 偽情報を避ける
- accountListという変数がList型でないのはよくない。accountGroup, accounts等がよい。(上に同じ)
- ごく一部のみが異なる変数名はよくない。XYZControllerForEfficientHandlingOfStringsとXYZControllerForEfficientStrangeOfStringsは見分けがつきづらい。
- o==1, l==0の見間違いを避ける。

## 意味のある対比
- zorkという変数がある時にtheZorkという変数を別で作るのは良くない。違いがわからない。
- ノイズワードは冗長的。"table"という単語は表の名前に入っているべきでない。NameとNameString、accountとaccountData、moneyとmoneyAmountは区別がつかない。

## 発音可能な名前をつける
- genymdhmsは発音できない。(generate, year, month, day, hour, minute, secondの省略)

## 検索可能な名前をつける
- マジックナンバー（7とか）は検索できない。MAX_CLASSES_PER_STUDENTは検索できる。
- 1文字の名前は小さなメソッド内のローカル変数のみで使用するのがよい。検索する必要ないから。(forループでi,j,kを使用する時)
- 変数名の長さは変数のスコープに対応する。

## エンコーディングを避ける
- 型、スコープ情報を変数名に入れるべきでない。
- 発音しづらい、ミスタイプの原因になる等。
- 型を変更したのに名前を変更し忘れる等。

## メンバープレフィクス
- メンバー変数に"m_"をつける必要はない。
- クラス、関数は十分に小さくすべき。

## メンタルマッピングを避ける
- コードを読む人が心の中で別の名前に変換するのを避ける。
- forループ以外の1文字変数は大抵の場合読み手の変換が入る。よくない。

## クラス名
- クラス、オブジェクトには名詞、名詞句をつける。(Customer, WikiPage, Accountなど)
- 動詞やManager、Data、Infoは避けるべき。

## メソッド名
- メソッドには動詞をつけるべき。(postPayment, deletePage, save等)

## 1つのコンセプトには1つの単語
- 1つの抽象概念には1つの名前。
- DeviceManagerとProtocolControllerは同じ。統一できる。

## 語呂合わせをしない
- "add"が「2つの値を連結する」という意味で使われている時、「唯一の引数をコレクションに追加する」のにaddは使うべきでない。(InsertやAppendが良い)

## 意味のある文脈を加える
- street, houseNumber, city, state, zipcode等の変数がある時にstateのみ別のメソッドで使用されていると困る。(全て住所関連の変数名)
- プレフィックスをつけることで文脈をつけられる。(addrCity, addrState, addrZipcode等)
- Addressクラスを用意するでもよい。

## 意味のない文脈を与えない
- 必要以上に文脈を名前につけるのは避ける。長く冗長な名前になる。


# 3章 関数

## 小さくする
- 小さい関数こそ優れている。
- ネストも避ける。

## 1つのことを行う
- 1つの関数では1つのことを行う。それ以外のことは行ってはいけない。

## 1つの関数に1つの抽象レベル
- 1つのことのみを行うために、規模は大小あれど1つの抽象レベルにあることを確認する。

### 逓減規則
- コードは上から下に読める必要がある。
- 動作の順番に書かれているのがよい。

## 関数の引数
- 理想的には引数は0。3以上は避けたい。

## 共通モナディック形式
- 1つの引数を渡す時、引数について照会を行う場合と、変換を行う場合がある。
- マイナー: 出力無し、関数呼び出しの際にシステムが変更され、引数は状態を変更する目的で使用される。

## フラグ引数
- 引数にboolを渡すのは良くない。
- TrueとFalseで動作が二つあるため。

## 引数オブジェクト
- 複数の引数を一つにまとめると数を減らせる。
- Circle makeCircle(double x, double y, double radius) -> Circle makeCircle(point center, double radius)

## 動詞とキーワード
- 関数名は洗練された動詞/名詞の組み合わせになる。
- write(name)より、writeField(name)がよい。

## DRY(Don't Repeat Yourself)原則
- 同一のアルゴリズムが複数関数で現れるのは良くない。アルゴリズムを変更する時に複数箇所直す必要があるから。
- 別のメソッドとして定義しておくのが良い。


# 4章 コメント
- コメントはよくても必要悪。
- コメントはコードでうまく表現することに失敗した時に補うために使用する。

## コードで説明する
- コメントに書きたかった内容を実行する関数を作れば大抵解決する。

## 良いコメント
- 真っ当なコメント(Copyright等)
- 情報を与えるコメント
- 意図の説明(なぜその選択したのか)
- 明確化(標準ライブラリ等は変更できないため)
- 結果に対する警告(特定のテストケースがなぜオフになっているか等)
- TODOコメント
- 強調(一見筋が通らないことを強調するのに使える)
- APIのdoc
## 良くないコメント
- ぶつぶついうコメント(情報が少ない)
- 冗長なコメント(コード読む方がはやい)
- 誤解を招くコメント
- 命令コメント(全ての関数にdocを強制する等。潜在的な嘘、間違いを含んでいる。)
- 日誌コメント
- ノイズコメント(既に明らかなことを言い換えている。)
- 恐るべきノイズ(間違いによる嘘)
- 使用する必要のない場所でのコメント
- 道標
- 閉じかっこコメント(関数を短くすることを考えるべき)
- 属性と署名
- コメントアウトされたコード。消して良い。なくならない。
- HTMLコメント
- 非局所的な情報(コメントは対象となるコードのそばに書く。システム全体に及ぶ情報は局所的に書くべきでない。)
- 多すぎる情報
- 不明確なつながり
- 関数ヘッダ(短い関数に解説は不要)
- 非公開コードのdoc


# 5章 書式化
- コードの書式化は重要である。保守容易性と拡張性に影響を与え続ける。

## 縦方向の書式化
- 大きいより小さいファイルがよい。それなりのシステムは200~500行のファイルで構成できる。
- 新聞と同じで、最初は高レベルの概念、下に行くと詳細が記述されるべき。

### 垂直概念分離性
- 概念ごと(インポートや各関数等)に空行で分離すべき。

### 垂直密度
- 近い概念のものは近い位置に置くべき。コメント等で分離されるべきでない。

### 垂直距離
- 近い概念のものは近い位置に置くべき。どの場所にあるか探し回らずに済むようにすべき。
- 変数宣言は使用される場所の近くで行う。
- ローカル変数は関数の最初に現れる。(関数が短い前提)
- インスタンス変数はクラスの頭で宣言される。(多くのメソッドで使用されるため)
  - 重要なのは良く知られた場所に置くこと。
- ある関数が別の関数を呼び出しているときも垂直方向に近い位置に置くべき。
- 呼び出される関数は呼び出す関数のすぐ下にあると良い。(概念が下に行くほど詳細になるため)

## 横方向の書式化
- 横方向の長さは120字くらいがよい。

### 水平分離性と密度
- 概念ごとに空白で分離すべき
  - =の両端に空白を入れるが、関数名と(の間には入れない。
  - 演算子の優先順位を空白の有無で示す等。

### 水平方向の位置合わせ
- あまり有用でない。
- 位置が揃ってないことよりも、リストが長いことが問題。

### インデント
- インデントにより読みやすいコードとなる。
- 短いif, while文でもインデントをつける。

### ダミーのスコープ
- 見づらい。避けるべき。

## チームの規則
- チームで仕事する際はチームで統一された規則に従うべき。


# 6章 オブジェクトとデータ構造

## データ抽象化
- データを抽象化された形式で表すのがよい。データの実装をしらせることなく、本質を操作することができるからである。

## データ/オブジェクトの非対称性
- 手続き型(データ構造を使用するコード)は新たな関数を既存のデータ構造に影響を与えることなく作成できるが、新たなデータ構造を追加するには既存の関数を変える必要がある。
- オブジェクト指向の場合は既存の関数を変えることなく新たなクラスを作成できるが、新たな関数を追加するには全てのクラスを変える必要がある。

## デメテルの法則
- オブジェクトを使用する場合、そのオブジェクトの内部について知るべきではない。
- クラスcのメソッドfは以下のオブジェクトのメソッドのみを呼び出すべき。
  - cそのもの
  - fで生成されたオブジェクト
  - fの引数で渡されたオブジェクト
  - cのインスタンス変数に保持されたオブジェクト
- outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()はだめ。
- オブジェクトとデータ構造を混ぜ合わたクラスを作ってはいけない

# 7章 エラー処理

## リターンコードではなく例外を使用する
- try-catchにより、アルゴリズムとエラー処理を分離することができる。

## 最初にtry-catch-finallyを書く
- tryのどこで終了してもcatch内で整合性が取れている必要がある。

## 例外で状況を伝える
- エラーの場所と原因を判断できるようにする。

## nullを返さない
- nullチェックを忘れる人的ミスは起こり得る。そもそも返さなければ良い。

## nullを渡さない
- nullを返すより悪い。


# 8章 境界
- ライブラリを使用する場合は直接呼び出さず、振る舞いを限定したラッパークラスを設けて依存しないようにすること。


# 9章 単体テスト

## TDD三原則
- テストコードと製品コードはほぼ同時に書く。(テストのほうが少し先行するように)
  - 第一則: 失敗する単体テストのコードを書く前に、製品のコードを書いてはならない。
  - 第二則: コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない。
  - 第三則: 現在失敗している単体テストが通るまで、次の製品コードを書いてはならない。

## コードの柔軟性、保守容易性、再利用性を維持しているのは単体テストである
- テストも柔軟性、保守容易性、再利用性を重視して綺麗に書くべき

## 1つのテストに1つのアサート
- 1つのテストに入るアサート文は少ないほうがいい

## 1つのテストに1つの概念
- アサート文を最小にし、1つの概念についてテストするのが最善のルール

## F.I.R.S.T
- Fast: 高速である。
- Independent: 独立している。
- Repeatable: 再現性がある。
- Self-Validating: 自己検証可能。
- Timely: 適時性がある。


# 10章 クラス







