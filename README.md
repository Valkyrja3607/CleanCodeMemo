# CleanCodeMemo

- [1章 クリーンコード](#1章-クリーンコード)
- [2章 意味のある名前](#2章-意味のある名前)
- [3章 関数](#3章-関数)
- [4章 コメント](#4章-コメント)
- [5章 書式化](#5章-書式化)
- [6章 オブジェクトとデータ構造](#6章-オブジェクトとデータ構造)
- [7章 エラー処理](#7章-エラー処理)
- [8章 境界](#8章-境界)
- [9章 単体テスト](#9章-単体テスト)
- [10章 クラス](#10章-クラス)
- [11章 システム](#11章-システム)
- [12章 創発](#12章-創発)
- [13章 同時並行性](#13章-同時並行性)
- [17章 においと経験則](#17章-においと経験則)

# 1章 クリーンコード
- 長期的に開発をしていくために、読みやすい、綺麗なコードを書く必要がある。


# 2章 意味のある名前

## 意図が明確な名前にする
- 日単位の経過時間 -> elapsedTimeInDays, daysSinceCreation, daysSinceModification, fileAgeInDays...
- theListのような型情報しかない名前は情報がないためよくない。(そもそも型情報を変数名にするのは非推奨)

## 偽情報を避ける
- accountListという変数がList型でないのはよくない。accountGroup, accounts等がよい。(上に同じ)
- ごく一部のみが異なる変数名はよくない。XYZControllerForEfficientHandlingOfStringsとXYZControllerForEfficientStrangeOfStringsは見分けがつきづらい。
- o==1, l==0の見間違いを避ける。

## 意味のある対比
- zorkという変数がある時にtheZorkという変数を別で作るのは良くない。違いがわからない。
- ノイズワードは冗長的。"table"という単語は表の名前に入っているべきでない。NameとNameString、accountとaccountData、moneyとmoneyAmountは区別がつかない。

## 発音可能な名前をつける
- genymdhmsは発音できない。(generate, year, month, day, hour, minute, secondの省略)

## 検索可能な名前をつける
- マジックナンバー（7とか）は検索できない。MAX_CLASSES_PER_STUDENTは検索できる。
- 1文字の名前は小さなメソッド内のローカル変数のみで使用するのがよい。検索する必要ないから。(forループでi,j,kを使用する時)
- 変数名の長さは変数のスコープに対応する。

## エンコーディングを避ける
- 型、スコープ情報を変数名に入れるべきでない。
- 発音しづらい、ミスタイプの原因になる等。
- 型を変更したのに名前を変更し忘れる等。

## メンバープレフィクス
- メンバー変数に"m_"をつける必要はない。
- クラス、関数は十分に小さくすべき。

## メンタルマッピングを避ける
- コードを読む人が心の中で別の名前に変換するのを避ける。
- forループ以外の1文字変数は大抵の場合読み手の変換が入る。よくない。

## クラス名
- クラス、オブジェクトには名詞、名詞句をつける。(Customer, WikiPage, Accountなど)
- 動詞やManager、Data、Infoは避けるべき。

## メソッド名
- メソッドには動詞をつけるべき。(postPayment, deletePage, save等)

## 1つのコンセプトには1つの単語
- 1つの抽象概念には1つの名前。
- DeviceManagerとProtocolControllerは同じ。統一できる。

## 語呂合わせをしない
- "add"が「2つの値を連結する」という意味で使われている時、「唯一の引数をコレクションに追加する」のにaddは使うべきでない。(InsertやAppendが良い)

## 意味のある文脈を加える
- street, houseNumber, city, state, zipcode等の変数がある時にstateのみ別のメソッドで使用されていると困る。(全て住所関連の変数名)
- プレフィックスをつけることで文脈をつけられる。(addrCity, addrState, addrZipcode等)
- Addressクラスを用意するでもよい。

## 意味のない文脈を与えない
- 必要以上に文脈を名前につけるのは避ける。長く冗長な名前になる。


# 3章 関数

## 小さくする
- 小さい関数こそ優れている。
- ネストも避ける。

## 1つのことを行う
- 1つの関数では1つのことを行う。それ以外のことは行ってはいけない。

## 1つの関数に1つの抽象レベル
- 1つのことのみを行うために、規模は大小あれど1つの抽象レベルにあることを確認する。

### 逓減規則
- コードは上から下に読める必要がある。
- 動作の順番に書かれているのがよい。

## 関数の引数
- 理想的には引数は0。3以上は避けたい。

## 共通モナディック形式
- 1つの引数を渡す時、引数について照会を行う場合と、変換を行う場合がある。
- マイナー: 出力無し、関数呼び出しの際にシステムが変更され、引数は状態を変更する目的で使用される。

## フラグ引数
- 引数にboolを渡すのは良くない。
- TrueとFalseで動作が二つあるため。

## 引数オブジェクト
- 複数の引数を一つにまとめると数を減らせる。
- Circle makeCircle(double x, double y, double radius) -> Circle makeCircle(point center, double radius)

## 動詞とキーワード
- 関数名は洗練された動詞/名詞の組み合わせになる。
- write(name)より、writeField(name)がよい。

## DRY(Don't Repeat Yourself)原則
- 同一のアルゴリズムが複数関数で現れるのは良くない。アルゴリズムを変更する時に複数箇所直す必要があるから。
- 別のメソッドとして定義しておくのが良い。


# 4章 コメント
- コメントはよくても必要悪。
- コメントはコードでうまく表現することに失敗した時に補うために使用する。

## コードで説明する
- コメントに書きたかった内容を実行する関数を作れば大抵解決する。

## 良いコメント
- 真っ当なコメント(Copyright等)
- 情報を与えるコメント
- 意図の説明(なぜその選択したのか)
- 明確化(標準ライブラリ等は変更できないため)
- 結果に対する警告(特定のテストケースがなぜオフになっているか等)
- TODOコメント
- 強調(一見筋が通らないことを強調するのに使える)
- APIのdoc
## 良くないコメント
- ぶつぶついうコメント(情報が少ない)
- 冗長なコメント(コード読む方がはやい)
- 誤解を招くコメント
- 命令コメント(全ての関数にdocを強制する等。潜在的な嘘、間違いを含んでいる。)
- 日誌コメント
- ノイズコメント(既に明らかなことを言い換えている。)
- 恐るべきノイズ(間違いによる嘘)
- 使用する必要のない場所でのコメント
- 道標
- 閉じかっこコメント(関数を短くすることを考えるべき)
- 属性と署名
- コメントアウトされたコード。消して良い。なくならない。
- HTMLコメント
- 非局所的な情報(コメントは対象となるコードのそばに書く。システム全体に及ぶ情報は局所的に書くべきでない。)
- 多すぎる情報
- 不明確なつながり
- 関数ヘッダ(短い関数に解説は不要)
- 非公開コードのdoc


# 5章 書式化
- コードの書式化は重要である。保守容易性と拡張性に影響を与え続ける。

## 縦方向の書式化
- 大きいより小さいファイルがよい。それなりのシステムは200~500行のファイルで構成できる。
- 新聞と同じで、最初は高レベルの概念、下に行くと詳細が記述されるべき。

### 垂直概念分離性
- 概念ごと(インポートや各関数等)に空行で分離すべき。

### 垂直密度
- 近い概念のものは近い位置に置くべき。コメント等で分離されるべきでない。

### 垂直距離
- 近い概念のものは近い位置に置くべき。どの場所にあるか探し回らずに済むようにすべき。
- 変数宣言は使用される場所の近くで行う。
- ローカル変数は関数の最初に現れる。(関数が短い前提)
- インスタンス変数はクラスの頭で宣言される。(多くのメソッドで使用されるため)
  - 重要なのは良く知られた場所に置くこと。
- ある関数が別の関数を呼び出しているときも垂直方向に近い位置に置くべき。
- 呼び出される関数は呼び出す関数のすぐ下にあると良い。(概念が下に行くほど詳細になるため)

## 横方向の書式化
- 横方向の長さは120字くらいがよい。

### 水平分離性と密度
- 概念ごとに空白で分離すべき
  - =の両端に空白を入れるが、関数名と(の間には入れない。
  - 演算子の優先順位を空白の有無で示す等。

### 水平方向の位置合わせ
- あまり有用でない。
- 位置が揃ってないことよりも、リストが長いことが問題。

### インデント
- インデントにより読みやすいコードとなる。
- 短いif, while文でもインデントをつける。

### ダミーのスコープ
- 見づらい。避けるべき。

## チームの規則
- チームで仕事する際はチームで統一された規則に従うべき。


# 6章 オブジェクトとデータ構造

## データ抽象化
- データを抽象化された形式で表すのがよい。データの実装をしらせることなく、本質を操作することができるからである。

## データ/オブジェクトの非対称性
- 手続き型(データ構造を使用するコード)は新たな関数を既存のデータ構造に影響を与えることなく作成できるが、新たなデータ構造を追加するには既存の関数を変える必要がある。
- オブジェクト指向の場合は既存の関数を変えることなく新たなクラスを作成できるが、新たな関数を追加するには全てのクラスを変える必要がある。

## デメテルの法則
- オブジェクトを使用する場合、そのオブジェクトの内部について知るべきではない。
- クラスcのメソッドfは以下のオブジェクトのメソッドのみを呼び出すべき。
  - cそのもの
  - fで生成されたオブジェクト
  - fの引数で渡されたオブジェクト
  - cのインスタンス変数に保持されたオブジェクト
- outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()はだめ。
- オブジェクトとデータ構造を混ぜ合わたクラスを作ってはいけない

# 7章 エラー処理

## リターンコードではなく例外を使用する
- try-catchにより、アルゴリズムとエラー処理を分離することができる。

## 最初にtry-catch-finallyを書く
- tryのどこで終了してもcatch内で整合性が取れている必要がある。

## 例外で状況を伝える
- エラーの場所と原因を判断できるようにする。

## nullを返さない
- nullチェックを忘れる人的ミスは起こり得る。そもそも返さなければ良い。

## nullを渡さない
- nullを返すより悪い。


# 8章 境界
- ライブラリを使用する場合は直接呼び出さず、振る舞いを限定したラッパークラスを設けて依存しないようにすること。


# 9章 単体テスト

## TDD三原則
- テストコードと製品コードはほぼ同時に書く。(テストのほうが少し先行するように)
  - 第一則: 失敗する単体テストのコードを書く前に、製品のコードを書いてはならない。
  - 第二則: コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない。
  - 第三則: 現在失敗している単体テストが通るまで、次の製品コードを書いてはならない。

## コードの柔軟性、保守容易性、再利用性を維持しているのは単体テストである
- テストも柔軟性、保守容易性、再利用性を重視して綺麗に書くべき

## 1つのテストに1つのアサート
- 1つのテストに入るアサート文は少ないほうがいい

## 1つのテストに1つの概念
- アサート文を最小にし、1つの概念についてテストするのが最善のルール

## F.I.R.S.T
- Fast: 高速である。
- Independent: 独立している。
- Repeatable: 再現性がある。
- Self-Validating: 自己検証可能。
- Timely: 適時性がある。


# 10章 クラス

## クラスは小さくしなければならない!
- クラスは小さくしなければならない。

### 単一責務の原則(SRP)
- SRP(Single Responsibility Peinciple)
- 責務は変更の原因となるため、1つがよい。

### 凝集性
- あるメソッドが操作する変数が多いほど、そのクラスの凝集性は高いと言える。

# 11章 システム
- ソフトウェアのチームは全体像に対して責任を負う人と、詳細について関心を持つ人がいる。
- クリーンコードは低いレベルの抽象化に役立つ。

## システムを使うことと構築することを分離する。

### mainの分離
- 構築に関する全てをmainで行い、アプリケーションで使用する。

### ファクトリ
- アプリケーション側で構築に責任を追わなければいけない時は、抽象ファクトリパターンを使う。
- アプリケーションから生成を分離できる。

### 依存性注入(DI)
- DI(Dependency Injection)
- オブジェクトの利用と生成を分離する仕組み(制御の反転の適用)
- myService = (myService)(jndiContext.lookup("NameOfMyService"));

### システムアーキテクチャのテスト実行
- 事前の大規模設計は不要。「ばかばかしいほど単純」でよい。
- よいAPIはほとんどの場面で視界の外になければいけない。

###　意思決定を最適化する
- 決定はそれが手遅れとなる直前まで延期するのが最適

# 12章 創発
- 優れた設計を生み出すために4つの単純な規則が存在する。(重要順)
  - 全テストを実行する。
  - 重複がない。
  - プログラムの意図が表現されている。
  - クラスとメソッドを最小化する。

# 13章 同時並行性

## なぜ同時並行性が必要なのか
- 分離のための戦略として必要

### 同時並行処理は難しい
- 同時並行性には余分なコードがつきまとう。
- 正しい同時並行性の確保は複雑となる。
- 同時並行性のバグには大抵再現性がない。

## 同時並行性防御原則

### 単一責務の原則
- 同時並行性に関するコードを他のコードのと分離する。
  - 同時並行性に関するコードはそれ自体が開発、変更、チューニングのライフサイクルを持っている。
  - 同時並行性に関するコードと、関しないコードの難しさは質が異なり困難。
  - バグの範囲が多岐にわたる。

### データのスコープを限定する
- データのカプセル化を徹底する。共有される可能性のあるデータへのアクセスを厳しく制限する。

### データのコピーをしようする
- データの共有を避けることができる。

### スレッドはできる限り独立させる
- スレッドがそれぞれ独立していればデータの共有がない。
- データをお互いに依存しないサブセットに分割するよう試みる。

## 同期化メソッド間の依存関係に注意
- 共有されるオブジェクトのメソッドを2つ以上しよいうしてはならない

## 同期化セクションを小さくする

## 正確な終了コードを書くのは難しい
- 早い時期に終了処理について考慮を行い、動作するようにする。

## スレッド化されたコードのテスト
- 潜在的問題をあぶり出すコードを書く。
- 異なるプログラム構成、システム設定で頻繁に実行する。

### 怪しい失敗を、スレッド問題の容疑者として扱う
- システムのエラーを一過性の問題と片付けないこと

### 最初にスレッド化されていないコードを完成させる
- マルチスレッドのバグと非マルチスレッドのバグを同時に追いかけない。
- 非マルチスレッドがまず動作するようにする。

### スレッド化されたコードは差し替え可能とする
- 様々な構成で実行可能にするため

### スレッド化されたコードをチューニング可能にしておく
- スループット、システム使用率をもとに使用するスレッド数を簡単に調整可能にしておく。

### プロセッサの数よりスレッドの数を多くする
- 問題はタスクスイッチする時に起こる。

### 異なるプラットフォームで実行する
- マルチスレッドのコードは肝虚いうが異なると挙動も異なる。
- なあるべく早い時期に、頻繁に、全ての対象プラットフォームで実行する。

### 様々なことを試し、強制的にエラーを発生させる
- 手作業によるもの
  - wait()、sleep()、yield()、priority()などを追加する。
- 自動的に行うもの
  - CGLIBやASMを使う


# 17章 においと経験則

##　コメント
### 不適切な情報
- コメントはコードと設計に関する技術的な注意書きのために用いる

### 退化コメント
- 退化コメントは消すか最新化する。

### 冗長なコメント
- i++  # iを1増やす

### 記述不足なコメント
### コメントアウトされたコード

## 環境
### ビルドに複数ステップを要する
- 1つのコマンドでビルドできるようにするべき

### テストに複数ステップを要する
- 1つのコマンドで単体テストできるようにするべき

## 関数
### 多すぎる引数
- 多くても3つ

### 出力引数
### フラグ引数
- Booleanは関数が2つ以上のことを行なっていることを表している。やめるべき。

### 死んだ関数
- どこからも呼び出されていない関数は削除する。

## 一般
### 1つのソースファイルに複数の言語を使用する
- 言語の数は減らすべき。

### あって当然の振る舞いが実装されていない
- プログラマが当然と期待する振る舞いを関数、クラスは行うべき。

### 境界値に対する不正確な振る舞い
- あらゆる境界条件でテストをする。

### 安全軽視

### 重複

### 抽象レベルが正しくないコード

### 継承クラスに依存したベースクラス
- ベースクラスは継承クラスの知識を持たない。

### 情報過多
- クラスのインスタンス数は少ないほうがいい。

### デッドコード
- 実行されないコード(if False)

### 垂直分離
- 変数と関数は使用される近くで定義されるべき。

### 不整合
- 関数AとBで同じ処理をするときは生合成を保つ(変数名を同じにする等)

### 雑然

### 人為的な結合
- 依存関係にないものは繋げてはいけない

### 機能の羨望

### セレクタ引数

### 不明確な意図

### 責務を持たせる場所の間違い
- コードは読み手が当然と思う場所に置く

### 不明確なstatic

### 説明的変数名

### 関数名は体を表すべき
- 呼び出された時に、何が行われるのかわかるようにする。

### アルゴリズムを理解する

### 論理的な依存性を物理的なものとする

### 標準の規約に従う

### マジックナンバーを定数にする

### 正確であれ

### 規約より構造

### 条件をカプセル化する
- if shouleBeDelete(timer) > if (timer.hasExpired() && !timer.isRecurrent())

### 条件の否定形を避ける
- if shouleBeDelete(timer) >　if !shouleNotBeDelete(timer)

### 関数では1つのことを行う

### 隠れた時間軸上の結合
- 時間軸上の結合を隠してはいけない

### 根拠を持つ

### 境界条件はカプセル化する

### 関数は1つの抽象レベルを担うべき

### 設定可能なデータは高いレベルに置く

### 繊維的なナビゲーションを避ける

## 名前

### 記述的な名前を選ぶ

### 抽象レベルに適切な名前を選ぶ

### 可能な限り標準の用語を使用する

### はっきりした名前

### 広いスコープには長い名前

### エンコーディングを避ける

### 名前で副作用を示すべき

## テスト

### 不十分なテスト

### カバレッジツールを使う

### 些細なテストを省略しない

### 無視することを指定されたテストは曖昧さをあらわす

### 境界条件のテスト

### バグの周辺は徹底的にテストする

### 失敗パターンからなにかしらわかるかもしれない

### テストカバレッジのパターンからなにかしらわかるかもしれない

### テストは高速に実行できるべき
